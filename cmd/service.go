package cmd

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

type serviceEntry struct {
	Module      string
	SubSegments []string
	FuncName    string
	ImportAlias string
	ImportPath  string
	Relative    string
}

// GenerateServices 扫描项目 service 目录，生成统一的 service 注册文件。
func GenerateServices(projectRoot string) error {
	if projectRoot == "" {
		projectRoot = "."
	}
	rootPath, err := filepath.Abs(projectRoot)
	if err != nil {
		return fmt.Errorf("解析项目根目录失败: %w", err)
	}

	moduleRoot := filepath.Join(rootPath, "module")
	output := filepath.Join(rootPath, "data", "service.go")

	moduleName := readModuleName(filepath.Join(rootPath, "go.mod"))
	if moduleName == "" {
		return fmt.Errorf("无法从 go.mod 读取 module 名，请检查文件")
	}

	var entries []serviceEntry
	importAliases := make(map[string]string)
	aliasUsage := make(map[string]int)

	if _, err := os.Stat(moduleRoot); err == nil {
		if walkErr := filepath.Walk(moduleRoot, func(path string, info os.FileInfo, err error) error {
			if err != nil || info.IsDir() {
				return nil
			}
			if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
				return nil
			}
			if !strings.Contains(path, string(os.PathSeparator)+"service"+string(os.PathSeparator)) &&
				!strings.HasSuffix(filepath.Dir(path), string(os.PathSeparator)+"service") {
				return nil
			}

			relPath, err := filepath.Rel(rootPath, path)
			if err != nil {
				return nil
			}

			entryList, err := analyzeServiceFile(moduleName, relPath, path, importAliases, aliasUsage)
			if err != nil {
				return err
			}
			entries = append(entries, entryList...)
			return nil
		}); walkErr != nil {
			return walkErr
		}
	} else if !os.IsNotExist(err) {
		return fmt.Errorf("访问 module 目录失败: %w", err)
	}

	sort.Slice(entries, func(i, j int) bool {
		if entries[i].Module == entries[j].Module {
			if strings.Join(entries[i].SubSegments, ".") == strings.Join(entries[j].SubSegments, ".") {
				if entries[i].FuncName == entries[j].FuncName {
					return entries[i].Relative < entries[j].Relative
				}
				return entries[i].FuncName < entries[j].FuncName
			}
			return strings.Join(entries[i].SubSegments, ".") < strings.Join(entries[j].SubSegments, ".")
		}
		return entries[i].Module < entries[j].Module
	})

	code, err := buildServiceFile(entries, importAliases)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(filepath.Dir(output), 0o755); err != nil {
		return fmt.Errorf("创建 data 目录失败: %w", err)
	}
	if err := os.WriteFile(output, []byte(code), 0o644); err != nil {
		return fmt.Errorf("写入 service.go 失败: %w", err)
	}

	if len(entries) == 0 {
		fmt.Println("⚠️ 未检测到 service 函数，已生成空的 data/service.go")
	} else {
		fmt.Println("✅ Services generated successfully → " + output)
	}
	return nil
}

func analyzeServiceFile(moduleName, relPath, fullPath string, importAliases map[string]string, aliasUsage map[string]int) ([]serviceEntry, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, fullPath, nil, parser.SkipObjectResolution)
	if err != nil {
		return nil, fmt.Errorf("解析文件 %s 失败: %w", relPath, err)
	}

	var entries []serviceEntry
	for _, decl := range file.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Recv != nil || fn.Name == nil || !fn.Name.IsExported() {
			continue
		}

		parts := strings.Split(relPath, string(os.PathSeparator))
		serviceIndex := indexOf(parts, "service")
		if serviceIndex <= 0 {
			continue
		}
		module := sanitizePathSegment(parts[serviceIndex-1])

		var subSegments []string
		for i := serviceIndex + 1; i < len(parts)-1; i++ {
			subSegments = append(subSegments, sanitizePathSegment(parts[i]))
		}

		importPath := moduleName + "/" + strings.Join(parts[:len(parts)-1], "/")
		alias := ensureAlias(importAliases, aliasUsage, importPath, filepath.Dir(relPath))

		entries = append(entries, serviceEntry{
			Module:      module,
			SubSegments: subSegments,
			FuncName:    fn.Name.Name,
			ImportAlias: alias,
			ImportPath:  importPath,
			Relative:    relPath,
		})
	}
	return entries, nil
}

func buildServiceFile(entries []serviceEntry, importAliases map[string]string) (string, error) {
	header := fmt.Sprintf(`// Code generated by dever; DO NOT EDIT.
// Generated at: %s
// Description: 自动注册 service，扫描 module/*/service/*.go，并将其接入 dever/core。
`, time.Now().Format("2006-01-02 15:04:05"))

	if len(entries) == 0 {
		return fmt.Sprintf(`%spackage data

import (
    "github.com/shemic/dever/core"
)

func init() {
    registerServices()
}

func registerServices() {
}
`, header), nil
	}

	builder := &strings.Builder{}
	builder.WriteString(header)
	builder.WriteString("package data\n\n")

	builder.WriteString("import (\n")
	moduleImports := make([]string, 0, len(importAliases))
	for path := range importAliases {
		moduleImports = append(moduleImports, path)
	}
	sort.Strings(moduleImports)
	for _, path := range moduleImports {
		alias := importAliases[path]
		builder.WriteString(fmt.Sprintf("    %s \"%s\"\n", alias, path))
	}
	if len(moduleImports) > 0 {
		builder.WriteString("\n")
	}
	builder.WriteString("    \"github.com/shemic/dever/core\"\n")
	builder.WriteString(")\n\n")

	builder.WriteString("func init() {\n")
	builder.WriteString("    registerServices()\n")
	builder.WriteString("}\n\n")

builder.WriteString("// registerServices 自动注册所有业务\n")
builder.WriteString("func registerServices() {\n")

seen := make(map[string]struct{})
unique := make([]serviceEntry, 0, len(entries))
for _, entry := range entries {
    name := computeServiceName(entry)
    if _, ok := seen[name]; ok {
        continue
    }
    seen[name] = struct{}{}
    unique = append(unique, entry)
}

if len(unique) == 0 {
    builder.WriteString("}\n")
    return builder.String(), nil
}

builder.WriteString("    core.RegisterMany(map[string]any{\n")
for _, entry := range unique {
    name := computeServiceName(entry)
    builder.WriteString(fmt.Sprintf("        \"%s\": %s.%s,\n", name, entry.ImportAlias, entry.FuncName))
}
builder.WriteString("    })\n")
builder.WriteString("}\n")
return builder.String(), nil
}

func computeServiceName(entry serviceEntry) string {
	base := entry.Module
	if len(entry.SubSegments) > 0 {
		base = base + "." + strings.Join(entry.SubSegments, ".")
	}
	return fmt.Sprintf("%s.%s", base, entry.FuncName)
}
