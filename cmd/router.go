package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode"
)

type routeEntry struct {
	path   string
	method string
	line   string
}

// GenerateRoutes 扫描项目 API 目录，生成统一的路由注册文件。
func GenerateRoutes(projectRoot string) error {
	if projectRoot == "" {
		projectRoot = "."
	}
	rootPath, err := filepath.Abs(projectRoot)
	if err != nil {
		return fmt.Errorf("解析项目根目录失败: %w", err)
	}

	moduleRoot := filepath.Join(rootPath, "module")
	output := filepath.Join(rootPath, "data", "router.go")

	// ✅ 读取 go.mod 模块名
	moduleName := readModuleName(filepath.Join(rootPath, "go.mod"))
	if moduleName == "" {
		return fmt.Errorf("无法从 go.mod 读取 module 名，请检查文件")
	}

	// ✅ 检测 server.Server 方法风格（Get 还是 GET）
	methodStyle := detectServerMethodStyle(filepath.Join(rootPath, "dever", "server"))
	fmt.Println("✅ 检测到 Server 方法风格:", methodStyle)

	var routes []routeEntry
	importAliases := make(map[string]string)
	aliasUsage := make(map[string]int)
	apiFuncRegexp := regexp.MustCompile(`func\s+(Get|Post|Put|Delete)([A-Z]\w*)\s*\(\s*[a-zA-Z_]*\s*\*\s*(?:[\w\.]+)?Context`)

	if _, err := os.Stat(moduleRoot); err == nil {
		if walkErr := filepath.Walk(moduleRoot, func(path string, info os.FileInfo, err error) error {
			if err != nil || info.IsDir() {
				return nil
			}
			if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
				return nil
			}
			if !strings.Contains(path, string(os.PathSeparator)+"api"+string(os.PathSeparator)) {
				return nil
			}

			relPath, err := filepath.Rel(rootPath, path)
			if err != nil {
				return nil
			}

			parts := strings.Split(relPath, string(os.PathSeparator))
			apiIndex := indexOf(parts, "api")
			if apiIndex <= 0 || len(parts) < 3 {
				return nil
			}
			module := sanitizePathSegment(parts[apiIndex-1])
			fileName := sanitizePathSegment(strings.TrimSuffix(parts[len(parts)-1], ".go"))

			importPath := moduleName + "/" + strings.Join(parts[0:len(parts)-1], "/")
			alias := ensureAlias(importAliases, aliasUsage, importPath, filepath.Dir(relPath))

			content, _ := os.ReadFile(path)
			matches := apiFuncRegexp.FindAllStringSubmatch(string(content), -1)
			for _, m := range matches {
				method := formatMethodName(m[1], methodStyle)
				funcName := m[1] + m[2]
				funcSnake := camelToSnake(m[2])
				routePath := fmt.Sprintf("/%s/%s/%s", module, fileName, funcSnake)
				line := fmt.Sprintf(`r.%s("%s", %s.%s)`,
					method, routePath, alias, funcName)
				routes = append(routes, routeEntry{
					path:   routePath,
					method: method,
					line:   line,
				})
			}
			return nil
		}); walkErr != nil {
			return walkErr
		}
	} else if !os.IsNotExist(err) {
		return fmt.Errorf("访问 module 目录失败: %w", err)
	}

	sort.Slice(routes, func(i, j int) bool {
		if routes[i].path == routes[j].path {
			return routes[i].method < routes[j].method
		}
		return routes[i].path < routes[j].path
	})

	routeLines := make([]string, len(routes))
	for i, r := range routes {
		routeLines[i] = r.line
	}

	var importLines []string
	if len(importAliases) > 0 {
		importPaths := make([]string, 0, len(importAliases))
		for imp := range importAliases {
			importPaths = append(importPaths, imp)
		}
		sort.Strings(importPaths)
		for _, imp := range importPaths {
			alias := importAliases[imp]
			importLines = append(importLines, fmt.Sprintf(`    %s "%s"`, alias, imp))
		}
	}

	header := fmt.Sprintf(`// Code generated by dever; DO NOT EDIT.
// Generated at: %s
// Description: 自动路由注册文件，扫描 module/*/api/*.go，根据函数命名生成 HTTP 路由。
// 示例：module/user/api/test.go -> func GetUser -> GET /user/test/get_user
//
`, time.Now().Format("2006-01-02 15:04:05"))

	serverImport := "github.com/shemic/dever/server"
	middlewareImport := fmt.Sprintf(`    "%s/middleware"`, moduleName)

	var code string
	var resultMsg string
	if len(routes) == 0 {
		code = fmt.Sprintf(`%spackage data

import (
    "%s"
    "%s/middleware"
)

// RegisterRoutes 自动注册所有模块路由
func RegisterRoutes(r server.Server) {
    middleware.Register()
    // 当前没有可注册的 API 路由
}
`, header, serverImport, moduleName)
		resultMsg = "⚠️ 未检测到路由函数，已生成空的 data/router.go"
	} else {
		bodyLines := make([]string, 0, len(routes)+1)
		bodyLines = append(bodyLines, "middleware.Register()")
		for _, line := range routeLines {
			bodyLines = append(bodyLines, line)
		}
		code = fmt.Sprintf(`%spackage data

import (
    "%s"
    "%s"
%s
)

// RegisterRoutes 自动注册所有模块路由
func RegisterRoutes(r server.Server) {
%s
}
`, header, serverImport, middlewareImport, strings.Join(importLines, "\n"), "    "+strings.Join(bodyLines, "\n    "))
		resultMsg = "✅ Routes generated successfully → " + output
	}

	os.MkdirAll(filepath.Dir(output), 0755)
	if err := os.WriteFile(output, []byte(code), 0644); err != nil {
		return err
	}

	fmt.Println(resultMsg)
	return nil
}

// ------------------------ 工具函数 ------------------------
func indexOf(parts []string, target string) int {
	for i, p := range parts {
		if p == target {
			return i
		}
	}
	return -1
}

func sanitizePathSegment(s string) string {
	clean := strings.TrimSpace(s)
	if clean == "" {
		return "unnamed"
	}
	clean = strings.ReplaceAll(clean, " ", "_")
	clean = strings.ReplaceAll(clean, "\\", "_")
	clean = strings.ReplaceAll(clean, "-", "_")
	return strings.ToLower(clean)
}

func ensureAlias(aliasMap map[string]string, usage map[string]int, importPath, relDir string) string {
	if alias, ok := aliasMap[importPath]; ok {
		return alias
	}
	base := buildAlias(relDir)
	count := usage[base]
	alias := base
	if count > 0 {
		alias = fmt.Sprintf("%s_%d", base, count)
	}
	usage[base] = count + 1
	aliasMap[importPath] = alias
	return alias
}

func buildAlias(relDir string) string {
	if relDir == "" || relDir == "." {
		return "api_root"
	}
	parts := strings.Split(relDir, string(os.PathSeparator))
	aliasParts := make([]string, 0, len(parts))
	for _, part := range parts {
		if part == "" || part == "." || part == "module" || part == "api" {
			continue
		}
		aliasParts = append(aliasParts, part)
	}
	if len(aliasParts) == 0 {
		aliasParts = append(aliasParts, "api")
	}
	alias := "api_" + strings.Join(aliasParts, "_")
	return normalizeIdentifier(alias)
}

func normalizeIdentifier(s string) string {
	var b strings.Builder
	lastUnderscore := false
	for i, r := range s {
		switch {
		case r >= 'a' && r <= 'z', r >= 'A' && r <= 'Z', r >= '0' && r <= '9':
			if i == 0 && r >= '0' && r <= '9' {
				b.WriteByte('_')
			}
			b.WriteRune(r)
			lastUnderscore = false
		default:
			if !lastUnderscore {
				b.WriteByte('_')
				lastUnderscore = true
			}
		}
	}
	alias := strings.Trim(b.String(), "_")
	if alias == "" {
		return "api_pkg"
	}
	if alias[0] >= '0' && alias[0] <= '9' {
		alias = "_" + alias
	}
	return strings.ToLower(alias)
}

// 自动读取 go.mod 的 module 名
func readModuleName(path string) string {
	file, err := os.Open(path)
	if err != nil {
		return ""
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module "))
		}
	}
	return ""
}

// 驼峰转下划线
func camelToSnake(s string) string {
	var result []rune
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				result = append(result, '_')
			}
			r = unicode.ToLower(r)
		}
		result = append(result, r)
	}
	return string(result)
}

// 检测 server.Server 方法风格（Get 还是 GET）
func detectServerMethodStyle(serverDir string) string {
	methodStyle := "Title" // 默认 r.Get()
	filepath.Walk(serverDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return nil
		}
		if !strings.HasSuffix(path, ".go") {
			return nil
		}
		content, _ := os.ReadFile(path)
		if strings.Contains(string(content), "func (") {
			if strings.Contains(string(content), "GET(") {
				methodStyle = "Upper"
			}
		}
		return nil
	})
	return methodStyle
}

// 格式化方法名（自动匹配 Get vs GET）
func formatMethodName(method, style string) string {
	if style == "Upper" {
		return strings.ToUpper(method)
	}
	return strings.Title(strings.ToLower(method))
}
